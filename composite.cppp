#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <boost/shared_ptr.hpp>

using namespace std;

class Component
{
    public:
        virtual void print() = 0;
};

class Composite : public Component
{
    string name;
    vector<boost::shared_ptr<Component> > elements;

    public:

    Composite(const string & s) : name(s) {}

    void add(boost::shared_ptr<Component> element){
        elements.push_back(element);
    }

    void remove(boost::shared_ptr<Component> element){ 
        // removes element from collection
        elements.erase(
                std::remove(elements.begin(), elements.end(), element),
                elements.end());
    }

    boost::shared_ptr<Component> getChild(int index){
        return elements[index];
    }

    void print() override
    {
        cout << name << endl;

        for (auto &e : elements)
            e->print();
    }
};

class Leaf : public Component
{
    string name;
    public:

    Leaf(string s) : name(s) {}

    void print() override
    {
        cout << name << endl;
    }
};

void printComp(Component & c)
{
    c.print();
}

int main()
{
    // unix directory structure
    boost::shared_ptr<Composite> root(new Composite("/"));
    boost::shared_ptr<Composite> usr(new Composite("usr"));
    boost::shared_ptr<Composite> home(new Composite("home"));
    boost::shared_ptr<Composite> dev(new Composite("dev"));
    boost::shared_ptr<Composite> user(new Composite("user"));
    boost::shared_ptr<Leaf> file(new Leaf("file.txt"));

    user->add(file); //on passe l'adresse d'un composant
    home->add(user);

    root->add(usr);
    root->add(dev);
    root->add(home);

    // composition of objects and object are treating in the same way 
    printComp(*root);
    printComp(*file);

    return 0;
}
